---
layout: post
title:  "新特性研究"
date:   2020-05-12
excerpt: "Stick to note down what I'v learnt"
tag:
- Hyperledger Fabric
---

<center><H2><b>新特性研究</b></H2></center><br>

### Fabric 2.0 

> 新的隐私模式支持、改进的智能合同管理、新的操作节点的方法。



#### 智能合约新的管理方式

​	Fabric2.0 分布式管理智能合约的方法提供了一种新的智能合约下载以及合约启动的方式。新的智能合约生命周期，在与账本（Ledger）进行交互之前达成多组织之间对链码（chaincode，也叫智能合约）参数的一致。例如智能合约的背书策略在与账本进行交互的时候就已经确定。

##### 链码安装之前就可以达成对链码的共识

​	在1.X的版本中，只能由一个组织机构进行设置智能合约的参数，而其他的组织只能进行拒绝智能合约的安装。新的生命周期允许**中心化的可信模型**或者**去中心化的可信模型中多数组织**共同在背书策略等其他细节功能上形成一致性之后，再进行智能合约的实例化，使其运行在channel上。

##### 链码升级的过程改进

​	之前的链码生命周期中，升级可以由单个组织发起，这就给channel中未安装新链码的成员带来风险。新的模式要求只有足够数量的组织批准智能合约升级后才能进行升级链码。

##### 更简单的背书政策和隐私数据集的更新方式

​	Fabric 生命周期支持在不重新打包或重新安装链码的情况下，更改背书策略或私有数据集合配置。新的版本中用户还可以使用默认的背书策略，这些策略需要channel中的多数组织结构同意，并且在组织加入或者退出时进行自动更新。

##### 链码打包方式改变

​	Fabric将链码打包在简单易读的tar文件中。这使得链码包的检查和多个组织的合约协作安装更加容易。

##### 一个包能在channel进行多个智能合约的启动

​	原先的生命周期定义，每一个链码在channel中使用的名字和版本都是在链码包进行安装的时候制定的。

​	在新的生命周期中，你可以使用单个链码包，在同一个或者不同个channel中使用不同名字进行多次安装。

##### 链码的包在不同的channel上不一定完全一样

​	组织可以自己扩展链码，例如为了他们组织的利益执行不同的验证。只要有所需数量的组织的链码执行结果匹配并为交易背书，该交易就会被验证并提交到帐本中。这还允许组织按照自己的时间单独推出小的修补程序，而不需要整个网络同步进行。


#### 用于共识和协作的新的链码应用模式

​	用于增强新链码生命周期管理的共识达成的去中心方法，同样也能被用于你的链码应用。这种新的方法能保证多个组织在将交易提交到账本之前能够对要合约数据达成认可。

##### 自动检查

​	组织可以在链码函数中添加自动检查，用以在背书交易提案之前进行附加信息的验证。

##### 去中心化共识

​	人们的决定可以通过链码中的多个交易来建模。链码可能要满足来自不同组织的参与者在账本交易中的协议和条件。然后，最终的链码提案可以验证所有交易者的条件是否得到满足，并最终完成所有通道成员之间业务交易。



#### 隐私数据的增强

​	Fabric2.0提供了一种隐私数据使用和共享的新模式，该版本中不再需要通过为所有想要参与交易的channel成员创建隐私数据集。

​	具体的说，你可能在多个成员集合之间共享数据，而不仅仅在一个成员集合当中。而这些集合也可能包括单一组织，或者是有监管者或者审计员的单一组织。

隐私数据改进地方：

##### 共享和验证私有数据

​	当私有数据与不是集合成员的通道成员共享时，或者与包含一个或多个通道成员的另一个私有数据集合共享时（通过向该集合写入密钥），接收方可以利用链码的 GetPrivateDataHash() API 对私有数据通过比较是否与以前交易中创建的私有数据在链上哈希相匹配来进行验证。**不是Fabric2.0才有的**

##### 集合级别的背书策略

​	现在可以选择使用背书策略来定义私有数据集合，*该背书策略会覆盖（集合当中键的）链码级的背书策略*。该特性可用于限制哪些组织可以将数据写入集合，并且正是它完成了前面提到的新的链码生命周期和链码应用程序模式。

##### 每个组织的隐式集合

​	在 Fabric v2.0 中部署链码时，不需要定义集合就能利用每个组织的私有数据模式。不需要任何前期定义就可以使用隐式的特定组织集合。**直接可以用隐含的组织特定集合进行数据共享，不用定义**



#### 外部的链码启动器

​	外部链码启动器让操作者可以自定义的构建和启动链码。外部的构建器和启动器不是必须的，在使用默认的习惯通过DockerAPI进行构建和启动链码时使用和之前版本一样。

##### 消除 Docker 守护进程依赖

​	Fabric 以前的版本要求 Peer 节点能够访问 Docker 守护进程，以便构建和启动链码。但是 Peer 节点进程所需的特权（管理员权限）在生产环境中是不合适的。

##### 容器的替代品

​	不再要求链码在 Docker 容器中运行，可以在自定义选择的环境（包括容器）中执行。

##### 可执行的外部构建器

​	开发中可以提供一组可执行的外部构建器，以覆盖 Peer 节点构建和启动链码方式。

##### 作为外部服务的链码

​	传统上，链码由 Peer 节点启动，然后连接回 Peer 节点。现在可以将链码作为外部服务运行，例如在 Kubernetes pod 中，Peer 节点可以连接到该 pod，并利用该 pod 执行链码。

> 了解更多作为外部服务的链码请查看 [Chaincode as an external service](https://hyperledger-fabric.readthedocs.io/zh_CN/latest/cc_service.html) 。
>
> 了解更多关于外部链码启动器的功能请查看 [External Builders and Launchers](https://hyperledger-fabric.readthedocs.io/zh_CN/latest/cc_launcher.html) 。


#### 状态数据库寄存器，提升CouchDB的性能

+ 在使用外部 CouchDB 状态数据库时，背书和验证阶段的读取延迟历来是性能瓶颈。
+ 在 Fabric v2.0 中，用快速的本地缓存读取取代了 Peer 节点中那些耗费资源的查找操作。可以使用 core.yaml 文件中的属性 `cachesize` 来配置缓存大小。



#### 基于Alpine的docker镜像

​	从2.0版本开始，Hyperledger Fabric Docker 镜像将使用 Alpine Linux 作为基础镜像，这是一个面向安全的轻量级 Linux 发行版。这意味着现在的 Docker 镜像要小得多，这就提供了更快的下载和启动时间，以及占用主机系统上更少的磁盘空间。Alpine Linux 的设计从一开始就考虑到了安全性，Alpine 发行版的最小化特性大大降低了安全漏洞的风险。


